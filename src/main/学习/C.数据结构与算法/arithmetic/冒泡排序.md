# Table of Contents

* [基本概念](#基本概念)
* [规则](#规则)
* [演化](#演化)
* [复杂度和稳定性](#复杂度和稳定性)
  * [冒泡排序时间复杂度](#冒泡排序时间复杂度)
  * [冒泡排序稳定性](#冒泡排序稳定性)





# 基本概念

+ 基本思想:<font color=red>通过对待排序序列从前向后(下标从小到大)，依次比较相邻的值，逆序则交换，使值大的元素从前移向后部。</font>

+ 优化：如果一躺下来，没有交换，说明序列有序。可以设置一个flag判断元素是否进行交换。减少不必要的比较



# 规则

1. 一共要进行n-1次排序(n=数组长度)
2. 每一次排序的次数在逐渐减少？为什么？前面的n次排序，已经将最大的元素后移了
3. 如果某趟排序，一次交换都没有。可以提前结束。



# 演化

1. 为什么第一层循环是n-1次
2. 为什么第二层循环是n-1次




```java
int arr[] = new int[]{3, 9, -1, 10, 20};
//时间复杂度 O(n^2)
int temp = 0;
for (int i = 0; i < arr.length - 1; i++) {
    //这里减i是点睛之笔 为什么要减i 经过上次的排序，数组最后的元素已经不需要排序了
    for (int j = 0; j < arr.length - 1 - i; j++) {
        if(arr[j]>arr[j+1]){
            temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }
    System.out.println("第" + (i + 1) + "趟排序后的数组");
    System.out.println(Arrays.toString(arr));
}
第1趟排序后的数组
[3, -1, 9, 10, 20]
第2趟排序后的数组
[-1, 3, 9, 10, 20]
第3趟排序后的数组
[-1, 3, 9, 10, 20]
第4趟排序后的数组
[-1, 3, 9, 10, 20]

```

大家可能发现了，第二次就已经是有序了，所以我们需要优化这段代码。

```java
int arr[] = new int[]{3, 9, -1, 10, 20};
//时间复杂度 O(n^2)
int temp = 0;
for (int i = 0; i < arr.length - 1; i++) {
    //这里减i是点睛之笔 为什么要减i 经过上次的排序，数组最后的元素已经不需要排序了
	boolean flag = false;//表示是否交换过
    for (int j = 0; j < arr.length - 1 - i; j++) {
        if(arr[j]>arr[j+1]){
			flag=true;
            temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }
    if (!flag) {
        break;
    }
    System.out.println("第" + (i + 1) + "趟排序后的数组");
    System.out.println(Arrays.toString(arr));
}
第1趟排序后的数组
[3, -1, 9, 10, 20]
第2趟排序后的数组
[-1, 3, 9, 10, 20]
```



# 复杂度和稳定性

##  冒泡排序时间复杂度

冒泡排序的时间复杂度是O(N2)。 假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢? N-1次！因此，冒泡排序的时间复杂度是O(N2)。

##  冒泡排序稳定性

冒泡排序是稳定的算法，它满足稳定算法的定义。 算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！
