# Table of Contents

* [基本思想](#基本思想)
  * [从上往下的归并排序](#从上往下的归并排序)
  * [从下往上的归并排序](#从下往上的归并排序)
* [代码实现](#代码实现)




# 基本思想

利用<font color=red>归并</font>的思想实现的排序方法,该算法采用经典的<font color=red>分治</font>策略。

分治法将问题 分成一些小的问题，然后递归求解，而治的阶段将分的阶段的各答案`修补`在一起，即分而治之。

根据具体的实现，归并排序包括"从上往下"和"从下往上"2种方式





## 从上往下的归并排序 
它与"从下往上"在排序上是反方向的。它基本包括3步: 

+ 分解 -- 将当前区间一分为二，即求分裂点 mid = (low + high)/2; 

+ 求解 -- 递归地对两个子区间a[low...mid] 和 a[mid+1...high]进行归并排序。递归的终结条件是子区间长度为1。 

+ 合并 -- 将已排序的两个子区间a[low...mid]和 a[mid+1...high]归并为一个有序的区间a[low...high]。

  

## 从下往上的归并排序

将待排序的数列分成若干个长度为1的子数列，然后将这些数列两两合并；

得到若干个长度为2的有序数列，再将这些数列两两合并；

得到若干个长度为4的有序数列，再将它们两两合并；

直接合并成一个数列为止。这样就得到了我们想要的排序结果。

(参考下面的图片) 

****


<div align=left>
	<img src=".images/alg-sort-merge-1.jpg" width="">
</div>



# 代码实现

```java
public static void mergeSort(int arr[], int left, int right, int[] temp) {

        if (left < right) {
            int mid = (left + right) / 2;
            mergeSort(arr, left, mid, temp);
            mergeSort(arr, mid + 1, right, temp);
            merge(arr, left, mid, right, temp);
        }

    }


    /**
     * 合并2各有序链表
     *
     * @param arr   排序的原始数组
     * @param left  左边有序序列的初始索引
     * @param mid   中间索引
     * @param right 右边索引
     * @param temp  临时数组
     */
    public static void merge(int arr[], int left, int mid, int right, int[] temp) {
        int i = left; //初始化i 左边有序序列的初始索引
        int j = mid + 1; //初始化j 右边有序序列的初始索引
        int t = 0; // 指向temp数组的当前索引

        //先把左右两边有序的的数据按照规则填充到temp数组,

        while (i <= mid && j <= right) {

            if (arr[i] <= arr[j]) {
                temp[t] = arr[i];
                t++;
                i++;
            } else {
                temp[t] = arr[j];
                t++;
                j++;

            }
        }

        while (i <= mid) {
            temp[t] = arr[i];
            t++;
            i++;
        }
        while (j <= right) {
            temp[t] = arr[j];
            t++;
            j++;
        }
        // 将temp的元素copy到arr中

        t = 0;
        int tempLeft = left;

        while (tempLeft <= right) {
            arr[tempLeft] = temp[t];
            t++;
            tempLeft++;

        }

    }
```
