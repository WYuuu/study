# Table of Contents

* [Count函数](#count函数)
* [MySQL中COUNT是怎样执行的](#mysql中count是怎样执行的)
                                                                  * [](#)
* [总结](#总结)


# Count函数

COUNT是一个汇总函数（聚集函数），它接收1个表达式作为参数：

```
COUNT(expr)
```

COUNT函数用于统计在符合搜索条件的记录中，指定的表达式`expr`不为NULL的行数有多少。这里需要特别注意的是，`expr`不仅仅可以是列名，其他任意表达式都是可以的。

比方说：

```
SELECT COUNT(key1) FROM t;
```

这个语句是用于统计在single_table表的所有记录中，key1列不为NULL的行数是多少。

再看这个：

```
SELECT COUNT('abc') FROM t;
```

这个语句是用于统计在single_table表的所有记录中，'abc'这个表达式不为NULL的行数是多少。很显然，'abc'这个表达式永远不是NULL，所以上述语句其实就是统计single_table表里有多少条记录。

再看这个：

```
SELECT COUNT(*) FROM t;
```

这个语句就是直接统计single_table表有多少条记录。

总结+注意：**COUNT函数的参数可以是任意表达式，该函数用于统计在符合搜索条件的记录中，指定的表达式不为NULL的行数有多少**。



# MySQL中COUNT是怎样执行的

以下边这个语句为例：

```
SELECT COUNT(*) FROM t;
```

这个语句是要去查询表t中共包含多少条记录。由于聚簇索引和二级索引中的记录是一一对应的，而二级索引记录中包含的列是少于聚簇索引记录的，所以同样数量的二级索引记录可以比聚簇索引记录占用更少的存储空间。如果我们使用二级索引执行上述查询，即数一下idx_key1中共有多少条二级索引记录，是比直接数聚簇索引中共有多少聚簇索引记录可以节省很多I/O成本。所以优化器会决定使用idx_key1执行上述查询：

```
mysql> EXPLAIN SELECT COUNT(*) FROM t;
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t     | NULL       | index | NULL          | idx_key1 | 5       | NULL |   16 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.02 sec)
```

在执行上述查询时，server层会维护一个名叫count的变量，然后：

•server层向InnoDB要第一条记录。

•InnoDB找到idx_key1的第一条二级索引记录，并返回给server层（**注意：由于此时只是统计记录数量，所以并不需要回表**）。

•由于COUNT函数的参数是`*`，MySQL会将`*`当作常数0处理。由于0并不是NULL，server层给count变量加1。

•server层向InnoDB要下一条记录。

•InnoDB通过二级索引记录的next_record属性找到下一条二级索引记录，并返回给server层。

•server层继续给count变量加1。

•... 重复上述过程，直到InnoDB向server层返回没记录可查的消息。

•server层将最终的count变量的值发送到客户端。



#那COUNT(1)，COUNT(id)，COUNT(非主键列)呢？

+ COUNT(1)，COUNT(id)，COUNT(*) 本质都是一样的。**优化器也会选择占用存储空间最小的那个索引来执行查询。**

+ `COUNT(非主键列)`来说，我们指定的列可能并不会包含在每一个索引中。这样优化器只能选择包含我们指定的列的索引去执行查询，这就**可能**导致优化器选择的索引并不是最小的那个。



# 总结

对于`COUNT(*)`、`COUNT(常数)`、`COUNT(主键)`形式的COUNT函数来说，优化器可以选择最小的索引执行查询，从而提升效率，它们的执行过程是一样的，只不过在判断表达式是否为NULL时选择不同的判断方式，这个判断为NULL的过程的代价可以忽略不计，所以我们可以认为`COUNT(*)`、`COUNT(常数)`、`COUNT(主键)`所需要的代价是相同的。

而对于`COUNT(非主键列)`来说，server层必须要从InnoDB中读到包含`非主键列`的记录，所以优化器并不能随心所欲的选择最小的索引去执行。
