# Table of Contents

* [什么是ES 深度分页？](#什么是es-深度分页)
* [scroll](#scroll)
* [**自增主键方式**](#自增主键方式)
* [创建时间](#创建时间)




# 什么是ES 深度分页？

es为了性能，限制了我们分页的深度，es目前支持的最大的 max_result_window = 10000；也就是说我们不能分页到10000条数据以上 ， 当ES 分页查询超过一定的值（10000）后，会报错：



# scroll 

普通的查询是比如说你要查第10000条的数据，es是通过协调节点从每个shard中都获取10000条数据返回给协调节点后，由协调节点返回给你排序后的第10000条数据，scroll是记录了上一次查询的结果后，下一次查询时以上一次的结果作为起点开始查询。 所以区别在一次搬1000块砖和一千次搬一块砖

每次搜索都是基于一个历史的数据快照，查询数据的期间，如果有数据变更，那么和搜索是没有关系的，搜索的内容还是快照中的数据。



# **自增主键方式**

可以为mapping增加一个自增长的int型字段（类似mysql的自增长主键） ， 当查询第一页时只带上分页条件：

```text
limit 0,1000
```

记录下返回的最大id的值${id_max}，查询第二页时 ：

```text
where id > ${id_max} limit 1000
```

这样我们就巧妙的利用了自增长的id来实现无内存消耗的全量查询。

缺点：

- 需要加一个额外字段，如果插入的时候是分布式，这个id必须使用redis等第三方来生成保证唯一自增。
- 插入ES的数据不能物理删除。



# 创建时间

通过创建时间来减少查询的分片数量。
