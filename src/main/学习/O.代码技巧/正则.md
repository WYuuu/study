# Table of Contents

* [练习网站](#练习网站)
* [基础语法](#基础语法)
  * [\\](#)
  * [()](#-1)
  * [[]](#-2)
  * [{}](#-3)
* [符号表](#符号表)
* [练习题目](#练习题目)
* [使用](#使用)
* [参考资料](#参考资料)


# 练习网站

[https://regexr-cn.com/]

# 基础语法

## \

> 将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\\n”匹配\n。“\n”匹配换行符。序列“\\”匹配“\”而“\(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。**就理解为转义符号**<br/>可以这么理解，如果不加‘\’，会被识别为 'w'字符，加了‘\’就会被识别为正则语法

比如要匹配一个"+"号，正则怎么写呢？

![image-20220115153209652](.images/image-20220115153209652.png)





## ()

>  分组捕获

举个例子：451w 或者451wr

你想匹配 451 w

 对应的正则表达式为：$$(\d){3}([a-z])+$$

那么第一个分组表达式就是提取451,第二个分组表达式提取的是w或者wr



## []

> 包含,默认是一个字符长度
>
> [^] 不包含,默认是一个字符长度

一般使用$$[A-Z]$$或者$$[0-9]$$



## {}

> {*n*,*m*}  匹配长度

匹配指定数量个前面的标记。`{1,3}` 会匹配1个到3个。`{3}` 会匹配正好3个。`{3,}` 会匹配3个或更多。



## $1 

$1，$2表达的是小括号()分组里面的内容：$1是第一个小括号里的内容，    $2是第二个小括号里面的内容，依此类推。例如：



**知道这个用法后，可以很方便的提取字符进行拼接。**

```java
String str = "451wt489bc5894";
System.out.println(str+"-->"+str.replaceAll("(\\d{3})(\\w+)(\\d{3})(\\w+)(\\d{4})","$5/$4+$3+$2+$1"));
```





# 符号表




| 元字符 | 描述                                       |
| :----: | :----------------------------------------------------------- |
| [A-Z] | 26个大写字母 |
| [a-z] | 26个小写字母 |
| [0-9] | 0至9数字 |
| [A-Za-z0-9] | 26个大写字母、26个小写字母和0至9数字 |
| ^ | **匹配输入字行首**。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。 |
| $    | **匹配输入行尾**。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。 |
| *    | **匹配前面的子表达式任意次**。例如，zo*能匹配“z”，也能匹配“zo”以及“zoo”。*等价于{0,}。<br/>**任意次可以为0次** |
| +    | **匹配前面的子表达式一次或多次(大于等于1次）**。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 |
| ? | 匹配前面的子表达式**零次或一次**。例如，“do(es)?”可以匹配“do”或“does”。?等价于{0,1}。 |
| \d | 匹配一个数字字符。等价于[0-9]。grep 要加上-P，perl正则支持 |
| \D | 匹配一个非数字字符。等价于[^0-9]。grep要加上-P，perl正则支持 |
| \w | 匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的"单词"字符使用Unicode字符集。 |
| \W | 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 |





# 练习题目

+  100.119.123.251 -> 251.123.119.100 数字颠倒

   ```java
   String str = "100.119.123.251";
   
   System.out.println(str+"->"+str.replaceAll("(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)","$4.$3.$2.$1"));
   
   100.119.123.251->251.123.119.100
   ```

+  匹配451wt489bc5894

   > (\d{3}\w+)(\d{3}\w+)(\d{4})

   



# 使用

```java
String str = "451wt489bc5894";
Pattern pattern = Pattern.compile("(\\d{3})(\\w+)(\\d{3})(\\w+)(\\d{4})");
Matcher matcher = pattern.matcher(str);
if(matcher.matches()){
    int count = matcher.groupCount();
    for(int i=1;i<=count;i++ ){
        System.out.println(matcher.group(i));
    }
}
451
wt
489
bc
5894

```

使用正则，我们可以根据正则表达式得到我们想要的某些元素，适用于提取某些数字和字符的结合。



# 参考资料 

[百度百科](https://baike.baidu.com/item/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/1700215)

