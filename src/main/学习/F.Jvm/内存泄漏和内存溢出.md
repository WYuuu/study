# Table of Contents

* [什么是内存泄漏？什么是内存溢出](#什么是内存泄漏什么是内存溢出)
* [Java会存在内存泄漏吗？请简单描述](#java会存在内存泄漏吗请简单描述)
* [如何定位内存溢出](#如何定位内存溢出)
* [如何避免内存溢出](#如何避免内存溢出)
* [虚拟机栈和本地方法栈溢出](#虚拟机栈和本地方法栈溢出)
* [本机直接内存溢出](#本机直接内存溢出)



# 什么是内存泄漏？什么是内存溢出

+ **内存溢出**: 内存溢出是指程序在申请内存时，没有足够的内存空间供其使用， 系统已经不能再分配出你所需要的空间

+ **内存泄漏**: 指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但是内存泄漏次数多了就会导致内存溢出。



# Java会存在内存泄漏吗？请简单描述

内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。

但是，即使这样，Java也还是存在着内存泄漏的情况，

**java导致内存泄露的原因很明确**：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。

> 最经典的就是ThreadLocal<弱，强>

# 如何定位内存溢出

**Java****堆内存溢出**时，异常堆栈信息“java.lang.OutOfMemoryError”会跟随进一步提示“Java heap space”。

常规的处理方法是

1. 首先通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析。

2. 确认内存中导致OOM的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出

3.  如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎 样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收它们

​     4.   如果不是内存泄漏，换句话说就是内存中的对象确实都是必须存活的，那就应当检查Java虚拟机 的堆参数（-Xmx与-Xms）设置，与机器的内存对比，看看是否还有向上调整的空间。再从代码上检查 是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。



# 如何避免内存溢出



1. **尽早释放无用对象的引用。**
2. **程序进行字符串处理时，尽量避免使用String，而应使用StringBuffer。**因为每一个String对象都会独立占用内存一块区域
3. **尽量少用静态变量。**因为静态变量是全局的，GC不会回收
4. 避免一次性使用过量数据
5. 使用对象池技术
6. 避免代码循环次数过多导致数据量偏大。



一切可以减少堆内存创建的，都可以减少内存溢出的机率。



# 虚拟机栈和本地方法栈溢出

1）如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。

2）如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出 OutOfMemoryError异常。



《Java虚拟机规范》明确允许Java虚拟机实现自行选择是否支持栈的动态扩展，而HotSpot虚拟机 的选择是不支持扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现 OutOfMemoryError异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法 容纳新的栈帧而导致StackOverflowError异常。



# 本机直接内存溢出

一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常 情况，如果读者发现内存溢出之后产生的Dump文件很小，而程序中又直接或间接使用了 DirectMemory（典型的间接使用就是NIO），那就可以考虑重点检查一下直接内存方面的原因了。

 

 
