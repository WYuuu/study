# Table of Contents

* [背景](#背景)
* [并发问题](#并发问题)
* [缓存数据不一致](#缓存数据不一致)
* [为什么需要JAVA内存模型](#为什么需要java内存模型)
* [问题](#问题)
  * [java内存模型解决了原子性？](#java内存模型解决了原子性)






# 背景

多线程下，我们都知道代码从编译到运行会设计几个问题：原子、可见、有序、。

在单线程下，无并发情况。编译器/runtime/处理器都遵守as-if-serial。所以没有并发问题。



# 并发问题

1. 缓存数据不一致。CPU有多个cache，之间数据同步如何处理。
2. CPU指令重排序在多线程下回导致代码在非预期下运行，最终会导致错误存在。





# 缓存数据不一致

1. 总线锁：同步
2. MESI:异步，但是会有其他问题，通过内存屏障来解决。

[详情见Volatile](Volatile.md)




# 为什么需要JAVA内存模型

由于不同CPU架构缓存体系不一样，缓存一致性协议不一样，重排序策略不一样，提供的内存屏障也可能不一样。为了简化Java开发人员的工作。Java封装了一套**规范**，这套规范就是【java内存模型】

【java内存模型】希望屏蔽各种硬件和操作系统的访问差异，保证java程序在各种平台下对内存访问都能得到一直效果。

> JAVA内存模型只是一种规范，JVM会实现这个规范。



# 问题

## java内存模型解决了原子性？

原子性是cpu分时复用引起的,JMM并没有解决。

