# Table of Contents

* [雪花算法](#雪花算法)
  * [存在问题](#存在问题)
  * [解决方案](#解决方案)








# 雪花算法



雪花算法是twitter提出的分布式id生成器方案，也叫发号器方案。这里简单介绍下雪花算法


![](.images/2773022-b2190fb402443fda.png)

+ 41bit时间戳：这里采用的就是当前系统的具体时间，单位为毫秒

+ 10bit工作机器ID（workerId）：每台机器分配一个id，这样可以标示不同的机器，但是上限为1024，标示一个集群某个业务最多部署的机器个数上限

+ 12bit序列号（自增域）：表示在某一毫秒下，这个自增域最大可以分配的bit个数，在当前这种配置下，每一毫秒可以分配2^12个数据，也就是说QPS可以到 409.6 w/s。



## 存在问题

+ 时间回拨问题：由于机器的时间是动态的调整的，有可能会出现时间跑到之前几毫秒，如果这个时候获取到了这种时间，则会出现数据重复

+ 机器id分配及回收问题：目前机器id需要每台机器不一样，这样的方式分配需要有方案进行处理，同时也要考虑，如果改机器宕机了，对应的workerId分配后的回收问题

+ 机器id上限：机器id是固定的bit，那么也就是对应的机器个数是有上限的，在有些业务场景下，需要所有机器共享同一个业务空间，那么10bit表示的1024台机器是不够的。



## 解决方案

你在内存里把过去1个小时之内生成的每一毫秒的每台机器生成的id都在内存里保存最大的那个id。

如果发生下面的情况：

12:00:00 500 28 20

12:00:04 300 28 8

如果发生了时钟回拨，此时你看看时钟汇报到了之前的哪一毫秒里去，直接接着在那一毫秒里的最大的id继续自增就可以了。

只需要拿最大的id然后自增就行了：

12:00:00 500 28 21
