# Table of Contents

* [带着BAT大厂的面试问题去理解](#带着bat大厂的面试问题去理解)
* [为什么需要多线程](#为什么需要多线程)
* [并发出现问题的根源: 并发三要素](#并发出现问题的根源-并发三要素)
  * [可见性: CPU缓存引起](#可见性-cpu缓存引起)
  * [原子性: 分时复用引起](#原子性-分时复用引起)
  * [有序性: 重排序引起](#有序性-重排序引起)
* [JAVA是怎么解决并发问题的: JMM(Java内存模型)](#java是怎么解决并发问题的-jmmjava内存模型)
* [关键字: volatile、synchronized 和 final](#关键字-volatilesynchronized-和-final)
* [线程安全: 不是一个非真即假的命题](#线程安全-不是一个非真即假的命题)
* [线程安全的实现方法](#线程安全的实现方法)
  * [互斥同步](#互斥同步)
    * [synchronized](#synchronized)
    * [ReentrantLock](#reentrantlock)
  * [非阻塞同步](#非阻塞同步)
    * [CAS](#cas)
  * [无同步方案](#无同步方案)
* [并发并行的区别](#并发并行的区别)





# 带着BAT大厂的面试问题去理解

+ 多线程的出现是要解决什么问题的?
+ 线程不安全是指什么? 举例说明 
+ 并发出现线程不安全的本质什么? 可见性，原子性和有序性。 
+ Java是怎么解决并发问题的? 3个关键字，JMM和8个Happens-Before 
+ 线程安全是不是非真即假? 不是
+ 线程安全有哪些实现思路?
+ 如何理解并发和并行的区别?


# 为什么需要多线程

充分利用资源

CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为: 
+ CPU 增加了缓存，以均衡与内存的速度差异；-> 导致 可见性问题 
+ 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；-> 导致 原子性问题 
+ 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。-> 导致 有序性问题

# 并发出现问题的根源: 并发三要素


## 可见性: CPU缓存引起

<font color=red>可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。</font> 举个简单的例子，看下面这段代码：

```java
 //线程1执行的代码
int i = 0;
i = 10;

//线程2执行的代码
j = i;

```
假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。 

此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10. 这就是可见性问题，

线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。 

## 原子性: 分时复用引起

<font color=red>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</font>

经典的转账问题：比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。 

试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。 

所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。


## 有序性: 重排序引起

<font color=red>有序性：即程序执行的顺序按照代码的先后顺序执行。</font>

```java
int i = 0;              
boolean flag = false;
i = 1;                //语句1  
flag = true;          //语句2
```

+ 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。



#  JAVA是怎么解决并发问题的: JMM(Java内存模型)

详情点击:[java内存模型](Java内存模型.md)

# 关键字: volatile、synchronized 和 final

+ volatile:[Volatile](Volatile.md)
+ synchronized:[synchronized](Synchronized.md)
+ final:暂无


# 线程安全: 不是一个非真即假的命题 


# 线程安全的实现方法 

## 互斥同步 

### synchronized

[synchronized](Synchronized.md)

### ReentrantLock

[ReentrantLock](AQS.md) 

## 非阻塞同步 

### CAS

[CAS](CAS.md)

## 无同步方案 


# 并发并行的区别

并发的关键是你有处理多个任务的能力，不一定要同时。
并行的关键是你有同时处理多个任务的能力。

所以我认为它们最关键的点就是：是否是『同时』。

