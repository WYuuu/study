# Table of Contents

* [秒杀简介](#秒杀简介)
* [传统方案](#传统方案)
  * [使用内存操作替代实时的DB事务操作](#使用内存操作替代实时的db事务操作)
  * [使用乐观锁替代悲观锁。](#使用乐观锁替代悲观锁)
* [微信红包解决方案](#微信红包解决方案)


# 秒杀简介

一个“秒杀”活动，对应DB中的一条库存记录。当用户进行商品“秒杀”时，系统的主要逻辑在于DB中库存的操作上。

一般来说，对DB的操作流程有以下三步：

a. 锁库存

b. 插入“秒杀”记录

c. 更新库存

秒杀”系统的设计难点就在这个事务操作上。

1. 商品库存在DB中记为一行，大量用户同时“秒杀”同一商品时，第一个到达DB的请求锁住了这行库存记录。
2. 在第一个事务完成提交之前这个锁一直被第一个请求占用，后面的所有请求需要排队等待。
3. 同时参与“秒杀”的用户越多，并发进DB的请求越多，请求排队越严重。
4. 因此，并发请求抢锁，是典型的商品“秒杀”系统的设计难点。



# 传统方案



普通商品“秒杀”活动系统，解决高并发问题的方案，大体有以下几种：



## 使用内存操作替代实时的DB事务操作

将“实时扣库存”的行为上移到内存Cache中操作，内存Cache操作成功直接给Server返回成功，然后异步落DB持久化


但是有个问题，Redis 有 decr 原子递减，redis 原子递减会变成负数，还是有超抢问题。





- 优点是用内存操作替代磁盘操作，提高了并发性能. 
- 但是缺点也很明显，在内存操作成功但DB持久化失败，或者内存Cache故障的情况下，DB持化会丢数据，不适合微信红包这种资金交易系统。

## 使用乐观锁替代悲观锁。

所谓乐观锁，

1. 它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。
2. 在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。
3. 如果其他事务有更新的话，正在提交的事务会进行回滚。

商品“秒杀”系统中，乐观锁的具体应用方法，

- 是在DB的“库存”记录中维护一个版本号。
- 在更新“库存”的操作进行前，先去DB获取当前版本号。
- 在更新库存的事务提交时，检查该版本号是否已被其他事务修改。如果版本没被修改，则提交事务，且版本号加1；
- 如果版本号已经被其他事务修改，则回滚事务，并给上层报错。

这个方案解决了“并发请求抢锁”的问题，可以提高DB的并发处理能力。



缺点：

- 会带来大数量的无效更新请求、事务回滚，给DB造成不必要的额外压力。
- 事务回滚，带来的体验不好。



# 微信红包解决方案

- 系统垂直SET化，分而治之。
  说白点就是直接分流，将请求按照某种规则分发到不同的机器上
- 逻辑Server层将请求排队，解决DB并发问题。
  对请求进行排队，FIFO队列，就不会出现并发抢锁的问题。
- 双维度库表设计，保障系统性能稳定
  


