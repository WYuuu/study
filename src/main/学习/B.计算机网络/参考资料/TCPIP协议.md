# TCP协议

## 1.特点

1.  TCP协议是有**连接**的，双方传输数据之前需要建立连接
2.  TCP提供可靠的服务，通过TCP连接传输的数据无差错、不丢失、不重复、且按序到达
3.  TCP是点对点通信
4.  TCP连接采用**全双工**工作模式

## 2.TCP报文段格式

### 2.1 端口号

作用：在同一台计算机中，进程间可以通过管道、共享内存、信号量、消息队列等进行通信，但都需要通过一个唯一的标识来确认相互通信的两个进程。一般可以通过进程号（PID）来标识不同的进程，但是PID仅在同一台计算机上唯一。而在两台不同的计算机中PID就无法唯一标识进程，在IP协议中，可以使用IP地址来唯一标识一台计算机，因此只用IP和端口号的组合就可以唯一地标识一台计算机中的进程。一些场合中也将IP地址和端口号的组合成为套接字（socket），端口号的范围为1~65535。

常用的服务以及对应的默认端口号：

| f服务名称              | 传输协议 | 默认端口号 |
| ---------------------- | -------- | ---------- |
| FTP（文件传输协议）    | TCP      | 21         |
| SSH（安全Shell服务）   | TCP      | 22         |
| Telnet                 | TCP      | 23         |
| DNS（域名解析服务）    | UDP      | 53         |
|                        | UDP      | 69         |
| HTTP（超文本传输协议） | TCP      | 80         |
| HTTPS                  | TCP      | 443        |
| SQLServer              | TCP      | 1433       |
| MySQL                  | TCP+UDP  | 3306       |
| Redis                  | TCP      | 6379       |
| MongoDB                | TCP      | 27017      |

### 2.2 序号和确认号

序号和确认号是TCP协议按序传输、不丢失不重复的核心。每发送一个报文段，序号都会增加报文段的长度。

### 2.3 数据偏移

由于TCP首部有可选字段，因此头部的长度是不固定的，而数据偏移就是用来标识TCP报文中的数据部分距离TCP报文的位置。

### 2.4 标志位

1. URG(urgent)：紧急标志位，置1时紧急指针字段有效，需要配合紧急指针使用。
2. ACK(acknowledged)：确认标志位，置1时表示确认号字段有效。
3. PSH(push)：推送标志位，置1时表示接收方应尽快将此报文交给应用层。
4. RST(reset)：重置标志位，置1时表示TCP连接发生故障，需要重新连接。
5. SYN(synchronize)：同步标志位，建立TCP连接时用来同步序号。
6. FIN(finish)：终止标志位，置1时表示数据发送完毕，需要关闭连接。

![](img\TCP报文段格式.png)

### 2.5 窗口

 窗口大小是TCP进行流量控制的关键，它指出了发送端和接收端的缓存大小，以此来进行流量控制。

### 2.6 校验和

对TCP头部和数据部分按16位进行计算得到，用来进行差错控制

### 2.7 紧急指针

当URG位1时才有效，指出了紧急报文段中的紧急数据的字节数

## 3.TCP的三次握手过程

### 3.1 第一次握手

客户端发送一个SYN请求报文（SYN=1，seq=x）到服务器，并进入**SYN_SENT**状态，等待服务器确认。SYN报文不携带其他数据，但需要消耗掉一个序号，同时客户端也会告知自己的接收窗口大小。

### 3.2第二次握手

服务端收到请求报文后如果同意建立连接，则向客户端发送确认报文（SYN=1，ACK=1，seq=y，ack=x+1）进入**SYN_RCVD**状态。确认报文同样不携带其他数据，并且也要消耗掉一个序号，服务端也会告知客户端自己的窗口大小。

### 3.3 第三次握手

客户端收到服务端的确认报文后进入**ESTABLISHED**状态，向服务器发送确认报文（ACK=1，seq=x+1，ack=y+1），服务器收到客户端的确认报文后也进入**ESTABLISHED**状态，至此客户端和服务器成功建立了TCP连接。

### 3.4 三次握手的流程图

![](img\TCP三次握手.jpg)

### 3.5 为什么需要三次握手才能建立连接？

因为TCP发送数据时，都需要维护一个序号，而三次握手是为了初始化双方的序列号。如果只有两次握手那么只有主动建立连接的一方的序列号能够得到确认，而另一方的初始化序列号将无法得到确认，因此需要通过第三次握手来实现另一方序列号的确认。

### 3.6 首次握手的隐患——SYN Flood攻击（DoS攻击）

由于三次握手过程中，当服务端接收到第一次握手的报文并进行响应后，TCP连接处于半连接状态，此时服务端会进入**SYN_RCVD**状态等待客户端的确认。如果发生超时，服务端将进行重传。在默认配置下，重传的次数是5，首次超时时长为1，因此服务器总计会等待1+2+4+8+16+32=63秒的时间，才判定该链接失效，因此容易被攻击者利用**SYN Flood**进行攻击。攻击者通过发送大量的SYN报文尝试与服务器进行连接，但发送后立即下线，以此来耗尽服务端的TCP连接队列，导致无法处理正常的TCP连接。

#### SYN Flood判断方法

通过netstat -an命令检查网络连接情况，如果发现大量的SYN_RECV（超过200条）并且服务器相应慢甚至是超时，可以认为受到了SYN Flood攻击

#### SYN Flood防范措施

1.  缩短SYN Timeout时间，由于SYN Flood攻击的效果取决于服务器上保持的SYN半连接数，这个值=**SYN攻击的频度 x  SYN Timeout**，所以通过缩短从接收到SYN报文到确定这个报文无效并丢弃改连接的时间，例如设置为20秒以下。但是过短的SYN Timeout时间可能会导致连接不稳定，一旦出现网络拥堵的情况很有可能导致客户端无法与服务端建立连接。
2. 启用SYN Cookies，SYN Cookies对三次握手进行了修改。原本的三次握手当中，当服务端接受到SYN报文后，便会为该连接分配一个TCB（传输控制块）。而SYN Cookies则是根据SYN报文来计算出一个Cookie值作为初始序列号。当客户端响应时，再根据响应的ACK来计算出原来的序列号是否与之匹配。若匹配则分配TCB，建立连接。
3. 限制IP访问，只允许特定的IP与服务器建立连接
4. 使用SYN Proxy防火墙
5.  流量清洗+流量回注技术，通过在IDC出口旁挂监控设备和防护设备以及路由技术来对流量进行引导和清洗。监控设备负责监测网络流量，如果监测到大量异常流量时，通过策略路由将异常流量引导至专业的防护设备上进行清洗。然后将正常的流量通过策略路由回注到网络当中，来实现对各种DDoS攻击的防护。

### 3.7 第三次握手失败时会发生什么?

TCP第三次握手时，如果客户端相应的ACK包因网络故障等因素没能及时达到服务端的话，服务端会在超时重试失败后向客户端发送一个RST报文来关闭该连接，避免泛洪攻击。

### 3.9  关于TCP中的backlog参数

backlog使用来设置TCP连接队列的大小，在建立连接时服务端需要维护一个队列来保存半连接（SYN_RCVD）和已建立的连接（ESTABLISHED）。一种方式是使用一个队列来保存这两种连接，另一种则是使用两个队列，一个用于保存半连接，另一个用于保存已建立的连接。

在早期的Linux版本中，只使用了一个队列来保存这两种连接，在这种方式下，如果队列已满（两种连接的数量已经达到backlog的值），此时若再有新的连接，那么服务端会直接抛弃该SYN报文，让客户端进行重试，而不是发送RST包来重置连接。

在Linux 2.2版本之后采用了两个队列来维护半连接和已建立的连接，分别是syns queue和accept queue，其中syns queue队列长度由系统指定，accept queue队列长度由backlog参数指定。当服务端接收到一个SYN连接请求时，便会将该连接放入到syns queue队列中，当三次握手成功后，便会将该连接取出并放入到accept queue当中去，处于accept queue中的连接都是可以使用的。当accept queue已满时，如果还有新的连接需要从syns queue移动到accept queue时，非/非/proc/sys/net/ipv4/tcp_abort_on_overflow设置成1(在这种情况会发送一个RST包)，否则服务端什么都不会做。

### 3.10 TCP保活机制（keepalive）

有时候我们需要使用TCP来建立长连接，但是在中途可能会有较长的一段时间双方没有数据需要发送，那么当再次有数据需要发送时，如何确定对方是否还正常，这个时候就需要TCP的保活机制。保活机制是通过一个定时器来实现的，每隔一段时间，启用保活机制的一方就会发送一个保活探测报文（该报文的需要seq为最后一次发送报文的seq-1，这样以后需要发送报文时，就不会受到探测报文的影响），如果对方仍然正常将会对该报文进行相应。若对方没有相应并且重试超过一定次数，那么该TCP连接就会被断开，或者另一方因崩溃等发生重启时将会相应一个RST报文来断开连接。与保活机制相关配置如下：

-   保活时间：默认7200秒
-   保活时间间隔：默认75秒
-   保活探测次数：默认9次

## 4.TCP的四次挥手过程

由于TCP连接是**全双工**的，因此每个方向都必须**单独进行关闭**。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

### 4.1 第一次挥手

客户端数据发送完毕后，主动发起关闭连接操作，客户端向服务端发送一个FIN报文（FIN=1，seq=u）并进入**FIN_WAIT_1**状态，等待服务器的相应。该报文可以携带也可以不携带数据，但一定需要消耗一个序号。

### 4.2 第二次挥手

服务端收到FIN报文，并发送确认报文给客户端（FIN=1，ACK=1，seq=w，ack=u+1）并进入**CLOSE_WAIT**状态，同时通知高层应用程序客户端已关闭连接。客户端收到服务器的确认报文后进入**FIN_WAIT_2**状态。此时连接处于半关闭状态，客户端不能再向服务端发送数据，但是服务端可以继续向客户端发送数据。

### 4.3 第三次挥手

当服务端发送数据完毕后，向客户端发送一个FIN报文（FIN=1，ACK=1，seq=w，ack=u+1）来关闭连接，并进入到**LAST_ACK**状态等待客户端相应该报文。

### 4.4 第四次挥手

客户端收到服务端发送的FIN报文后响应一个ACK报文（ACK=1，seq=u+1，ack=w+1）然后进入到**TIME_WAIT**状态，并**等待2个MSL**（maximum segment lifetime，在Windows下是2分钟，在Linux下默认是30秒）后关闭该连接。服务端收到该ACK报文后将连接关闭。

### 4.5 TCP四次挥手流程图

![](img\TCP四次挥手.png)

### 4.6 为什么需要四次挥手来断开连接？

因为TCP是全双工通信，断开一个方向的连接都需要一个FIN报文和一个ACK报文，所以断开一个TCP连接需要四次挥手。

### 4.7 为什么客户端在进行第四次挥手之后需要等待2个MSL才进入关闭状态？

- 确保有足够的时间让服务端接收到最后一个ACK报文，即便最后一个ACK发生超时，那么客户端也有足够的时间等待服务端重发第三次挥手的报文，因为等待时间至少是Timeout+FIN的单向传输延时，采用2个MSL更加保守一些。
- 为了避免新旧连接的数据包混淆，有些路由器会缓存IP数据包，如果连接被重用了，那么就有可能导致旧连接的数据包和新连接的数据包混淆，造成连接异常。

### 4.8 服务器出现大量的CLOSE_WAIT的原因及解决办法

**出现CLOSE_WAIT的原因**：CLOSE_WAIT是被动关闭TCP连接的一方才会保持的状态，如果被动关闭连接一方在收到主动方关闭连接的请求后没有对该请求做处理，就有可能使连接处于CLOSE_WAIT状态。最常见的就在程序中没有对资源即时地进行回收，即没有显示地去调用close()方法将连接关闭，从而导致程序长时间占用TCP连接而没有进行释放。一般来说处于CLOSE_WAIT状态的TCP连接会在2小时后自行关闭，但是对于服务器而言是致命的，可能会造成服务器资源不足从而拒绝新的连接。

**大量CLOSE_WAIT的解决办法**：由于大量的CLOSE_WAIT基本都是是由于程序自身的问题造成的（如：没有即时释放资源、线程池配置不合理等），使得服务器对于程序抢占的资源没有主动回收的权利，因此无法通过调整服务器参数来改变大量CLOSE_WAIT的问题，只能结合实际的业务对程序进行排查和修改修改，对于不需要的连接资源即时释放，避免长时间占用。

### 4.8 大量的TIME_WAIT以及大量的CLOSE_WAIT



## 附：TCP的11种状态变迁图

![](img\TCP状态变迁图.png)

## 5.TCP滑动窗口

## 6.TCP流量控制

## 7.TCP拥塞控制

### 7.1什么是拥塞

拥塞是指在某段时间，如果对网络中的某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要发生变化，这种情况叫拥塞

### 7.2拥塞控制的目的

进行拥塞控制是为了防止过多的流量被注入到网络当中，这样可以防止网络中的路由器或者链路过载

### 7.3拥塞控制算法

- 慢启动

  慢启动的思想是：如果一开始就将大量的数据注入到网络当中，由于尚不了解网络的拥塞情况，有可能会立即引发网络拥塞。所以以试探的方式逐渐增大发送窗口。在刚开始发送报文段时，先将拥塞窗口cwnd设置为1个最大报文段MSS的数值，每收到一个报文段的确认后，将窗口增大一倍。使用慢启动算法时，一般需要设置慢启动门限ssthresh值，在拥塞窗口达到该值之前使用慢启动算法，超过门限值后改用拥塞避免算法

- 拥塞避免

  当拥塞窗口较大时，如果继续使用慢启动算法，很有可能在某次成功发送报文后的下一次产生拥塞，因此采取逐渐增加拥塞窗口的方式来避免拥塞。一般每成功发送一个报文段就将拥塞窗口增大1。

- AIMD（加法增大，乘法减小）

  加法增大：指拥塞窗口达到拥塞门限值之后，缓慢增大拥塞窗口来避免拥塞

  乘法减小：指在出现网络超时时，不管使用慢启动还是拥塞避免算法，都立即将拥塞窗口置为1，拥塞门限窗口置为原来的一半

  ![](img/AIMD.jfif)

- 快速重传

  由于TCP采用累计确认机制，当接收端收到比期望序号大的报文段时，会重复发送最近一次确认的报文段序号（即冗余ACK）。快速重传是指当发送方连续接收到3个冗余（即4个相同序号的ACK）的ACK后，立即重传与该序号相同的报文段。

  虽然TCP能够确保数据包按顺序传输，但是由于网络环境因素以及IP协议的无序性，接收方往往不一定能够按序接收到报文，所以需要冗余ACK达到一定的次数才认为发生了丢包，3次冗余属于经验值。

  ![](img/TCP快速重传.jpg)

- 快速恢复

  由于使用乘法减小算法时，会立即将拥塞窗口cwnd设置为1，ssthresh减半，然后改用慢启动算法。虽然这么做能够避免拥塞，但是收到3个冗余ACK时，说明已经有其他3个报文被成功传输，网络未必处于拥塞状态。因此发送方将拥塞窗口cwnd设置回ssthresh的大小，然后使用拥塞避免算法。

  ![](img/TCP快速恢复.jfif)

## 8.TCP性能调优

### 8.1 大量的TIME_WAIT

TIME_WAIT是主动发起关闭连接的一方保持的状态，如果服务器主动关闭连接，在高并发短连接的场景下就会出现大量的TIME_WAIT，导致短时间内端口资源耗尽从而无法建立新的连接。

**当服务器出现大量的TIME_WAIT时，如何处理？**

修改修改/etc/sysctl.conf中的参数：
①net.ipv4.tcp.tw_reuse = 1 表示开启重用，允许将处于TIME_WAIT的socket重新用于新的TCP连接
②net.ipv4.tcp.tw_recycle = 1 表示开启TCP连接中TIME_WAIT的快速回收
③net.ipv4.tcp_fin_timeout 修改默认的TIMEOUT时间

### 7.2 大量的CLOSE_WAIT



**当服务器出现大量的CLOSE_WAIT时，如何处理？**

**



## OSI七层模型

![](img\OSI七层模型.jpg)

## TCP与UDP的区别

|      | TCP                                  | UDP                        |
| ---- | ------------------------------------ | -------------------------- |
|      | 面向连接的，发送数据前必须先建立连接 | 无连接，直接发送数据包     |
|      | 能够保证数据包的顺序                 | 不保证数据包顺序           |
|      | 能够进行流量控制和拥塞控制机制       | 没有流量控制和拥塞控制机制 |

## TCP的粘包和拆包问题

在传输层中只有数据帧没有数据包的概念，所谓包是指应用层中的数据包，所谓拆包粘包也是相对于应用层数据包而言。

UDP是基于报文发送的，从UDP的帧结构可以看出，在UDP首部采用了16bit来指示UDP数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。

而TCP是基于字节流的，虽然应用层和TCP传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界；另外从TCP的帧结构也可以看出，在TCP的首部没有表示数据长度的字段，基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。

### 粘包、拆包表现形式：

- 正常情况：没有发生粘包、拆包

  ![](img/TCP粘包1)

- 粘包：两个或者多个数据包被封装到了一个TCP数据帧当中

  ![](img/TCP粘包2.jpg)

- 粘包和拆包：一个数据包的一部分与另一个数据包被封装到了同一个TCP数据帧当中

  ![](img/TCP粘包3.jpg)

### 发生粘包和拆包的原因：

- 要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包

- 待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包

- 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包

- 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包

### 拆包、粘包的解决方法：

- 发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了
- 发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来
- 可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开

## TCP保证传输可靠的方法

- 序列号
- 检验和
- 确认应答信号
- 重发控制
- 连接管理
- 滑动窗口
- 流量控制
- 拥塞控制

# UDP协议

## 1.特点

1. 面向非连接
2. 不需要维护连接状态，支持一对多传输
3. UDP头部只有8个字节，额外开销少
4. 尽最大努力交付，不保证可靠交付，不需要维持复杂的连接状态表
5. 吞吐量只受限于数据生成的速率、传输速率和机器性能